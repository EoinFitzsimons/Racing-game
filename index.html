<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Championship Racing Circuit</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
            color: white;
            min-height: 100vh;
        }

        #gameContainer {
            position: relative;
            max-width: 1400px;
            margin: 0 auto;
            background: #333;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
        }

        #gameCanvas {
            display: block;
            background: #2a5a2a;
            width: 800px;
            height: 600px;
        }

        #sidePanel {
            width: 350px;
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.9);
        }

        #ui {
            padding: 15px;
            background: rgba(0,0,0,0.8);
            border-bottom: 1px solid #555;
        }

        #bettingPanel {
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            border-bottom: 1px solid #555;
        }

        #leaderboard {
            padding: 15px;
            background: rgba(0,0,0,0.8);
            min-height: 200px;
            border-bottom: 1px solid #555;
        }

        #commentary {
            padding: 15px;
            background: rgba(0,0,0,0.9);
            min-height: 150px;
            max-height: 200px;
            overflow-y: auto;
            border-bottom: 1px solid #555;
        }

        .commentary-line {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #FFD700;
            background: rgba(255,255,255,0.05);
            font-size: 12px;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .team-card {
            background: rgba(255,255,255,0.1);
            margin: 8px 0;
            padding: 8px;
            border-radius: 8px;
            border-left: 4px solid;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .team-card:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }

        .team-card.selected {
            background: rgba(255,215,0,0.3);
            box-shadow: 0 0 15px rgba(255,215,0,0.5);
        }

        .team-name {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .team-story {
            font-size: 9px;
            color: #ccc;
            margin-bottom: 5px;
            line-height: 1.2;
        }

        .team-odds {
            font-size: 10px;
            color: #4CAF50;
            font-weight: bold;
        }

        #betControls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #555;
        }

        #betAmount {
            width: 100%;
            padding: 6px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
            color: white;
            text-align: center;
            font-size: 12px;
        }

        #placeBetBtn, #startRaceBtn {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s ease;
            font-size: 12px;
        }

        #placeBetBtn:hover, #startRaceBtn:hover {
            background: #45a049;
        }

        #placeBetBtn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #wallet {
            background: rgba(255,215,0,0.2);
            padding: 8px;
            border-radius: 5px;
            text-align: center;
            margin-bottom: 10px;
            border: 1px solid #FFD700;
            font-size: 12px;
        }

        .position-item {
            margin: 3px 0;
            font-size: 12px;
            padding: 5px;
            border-radius: 3px;
            background: rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .position-number {
            font-weight: bold;
            width: 20px;
        }

        .position-change {
            font-size: 10px;
            font-weight: bold;
        }

        .position-up { color: #4CAF50; }
        .position-down { color: #f44336; }
        .position-same { color: #FFD700; }

        #raceResults {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 25;
            border: 2px solid #FFD700;
        }

        .story-details {
            background: rgba(0,0,0,0.8);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 40px;
            display: none;
            z-index: 30;
            overflow-y: auto;
        }

        .story-content {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 15px;
        }

        .close-story {
            position: absolute;
            top: 20px;
            right: 30px;
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }

        @media (max-width: 1200px) {
            #gameContainer {
                flex-direction: column;
                max-width: 800px;
            }
            
            #sidePanel {
                width: 100%;
                max-height: 400px;
                overflow-y: auto;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="sidePanel">
            <div id="ui">
                <div style="display: flex; justify-content: space-between;">
                    <div>Race: <span id="raceNumber">1</span></div>
                    <div>Time: <span id="timer">0:00</span></div>
                    <div>Status: <span id="raceStatus">Betting Open</span></div>
                </div>
            </div>

            <div id="bettingPanel">
                <div id="wallet">
                    üí∞ Wallet: $<span id="money">1000</span>
                </div>
                
                <h4 style="text-align: center; margin-bottom: 10px; font-size: 14px;">üèÅ Championship Teams</h4>
                
                <div id="teamsList"></div>
                
                <div id="betControls">
                    <input type="number" id="betAmount" placeholder="Bet Amount" min="10" max="1000" value="50">
                    <button id="placeBetBtn" disabled>Place Bet</button>
                    <button id="startRaceBtn">Start Race!</button>
                </div>
                
                <div id="currentBet" style="margin-top: 10px; font-size: 11px; color: #FFD700;"></div>
            </div>

            <div id="leaderboard">
                <div style="font-weight: bold; margin-bottom: 10px; font-size: 14px;">üèÜ Live Positions</div>
                <div id="positions"></div>
            </div>

            <div id="commentary">
                <div style="font-weight: bold; margin-bottom: 10px; font-size: 14px;">üì¢ Race Commentary</div>
                <div id="commentaryFeed"></div>
            </div>
        </div>

        <div id="raceResults">
            <h2>üèÅ Race Complete!</h2>
            <div id="winnerAnnouncement"></div>
            <div id="payoutInfo"></div>
            <button onclick="resetRace()" style="margin-top: 20px; padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Next Race</button>
        </div>

        <div id="storyDetails" class="story-details">
            <button class="close-story" onclick="closeStory()">‚úï</button>
            <div class="story-content" id="storyContent"></div>
        </div>
    </div>

    <script>
        // Team stories and data
        const teams = [
            {
                id: 0,
                name: "Crimson Shadows",
                color: "#ff4444",
                genre: "Dark Fantasy",
                tone: "Mysterious and intense",
                setting: "Underground racing circuits in a post-apocalyptic cityscape",
                style: "Gritty realism with supernatural elements",
                plot: "Former street racers turned shadow operatives seeking redemption",
                characters: "Raven (driver) - A reformed criminal with photographic memory for racing lines",
                conflict: "Battling inner demons while racing to fund an orphanage",
                theme: "Redemption through sacrifice",
                pov: "Third person limited (Raven's perspective)",
                dialogue: "Terse, meaningful exchanges laden with subtext",
                symbolism: "Red represents both blood and rebirth",
                story: "Born from the ashes of the Great Circuit Wars, Crimson Shadows emerged when underground racer 'Raven' discovered their illegal winnings were being used to fund a children's sanctuary.",
                odds: "4:1",
                skill: 0.75,
                personality: "aggressive"
            },
            {
                id: 1,
                name: "Neon Velocity",
                color: "#44ff44",
                genre: "Cyberpunk",
                tone: "Electric and rebellious",
                setting: "Neo-Tokyo 2087, holographic racing circuits",
                style: "High-tech prose with rapid-fire pacing",
                plot: "Corporate hacker races to expose mega-corp corruption",
                characters: "Zap (driver) - Augmented street racer with neural implants",
                conflict: "Evading corporate assassins while maintaining racing performance",
                theme: "Technology vs. humanity",
                pov: "Second person (You are the rebellion)",
                dialogue: "Tech-heavy slang mixed with philosophical observations",
                symbolism: "Green light represents the digital frontier and freedom",
                story: "In the neon-soaked streets of Neo-Tokyo, Zap races with illegal neural mods that sync directly with their vehicle.",
                odds: "3:1",
                skill: 0.80,
                personality: "technical"
            },
            {
                id: 2,
                name: "Azure Lightning",
                color: "#4444ff",
                genre: "Epic Adventure",
                tone: "Heroic and inspiring",
                setting: "Floating sky cities connected by storm clouds",
                style: "Lyrical and grandiose",
                plot: "Sky pirate seeks to unite the fractured aerial kingdoms",
                characters: "Storm (driver) - Noble sky pirate with a heart of gold",
                conflict: "Overcoming political intrigue while mastering storm-riding",
                theme: "Unity through adversity",
                pov: "Omniscient narrator celebrating heroic deeds",
                dialogue: "Formal speech patterns with nautical terminology",
                symbolism: "Blue represents both sky freedom and royal nobility",
                story: "Captain Storm once commanded the fastest cloudship in the Seven Skies until politics grounded their fleet.",
                odds: "5:1",
                skill: 0.70,
                personality: "steady"
            },
            {
                id: 3,
                name: "Golden Eagles",
                color: "#ffff44",
                genre: "Sports Drama",
                tone: "Triumphant and emotional",
                setting: "International racing academies and championship circuits",
                style: "Inspirational with focus on personal growth",
                plot: "Underdog team fights for recognition in elite racing circles",
                characters: "Phoenix (driver) - Small-town racer with big dreams",
                conflict: "Overcoming class prejudice and financial limitations",
                theme: "Dreams transcend circumstances",
                pov: "First person (Phoenix's journal entries)",
                dialogue: "Heartfelt conversations about hopes and fears",
                symbolism: "Gold represents both wealth aspired to and inner worth discovered",
                story: "From a small farming town, Phoenix learned to race on dusty back roads with a hand-me-down vehicle.",
                odds: "6:1",
                skill: 0.65,
                personality: "underdog"
            },
            {
                id: 4,
                name: "Violet Storm",
                color: "#ff44ff",
                genre: "Magical Realism",
                tone: "Mystical and contemplative",
                setting: "Ancient racing grounds where reality bends",
                style: "Flowing prose with unexpected magical elements",
                plot: "Mystical racer channels elemental forces to break ancient curses",
                characters: "Mystic (driver) - Seer who races between dimensions",
                conflict: "Balancing magical duties with mortal competition",
                theme: "Balance between worlds",
                pov: "Stream of consciousness with mystical insights",
                dialogue: "Poetic speech that hints at deeper meanings",
                symbolism: "Purple bridges the physical and spiritual realms",
                story: "Legend speaks of a racer who sees the wind before it blows and knows the track before it's built.",
                odds: "7:1",
                skill: 0.60,
                personality: "mystical"
            },
            {
                id: 5,
                name: "Aqua Titans",
                color: "#44ffff",
                genre: "Science Fiction",
                tone: "Sleek and progressive",
                setting: "Underwater cities and submarine racing tubes",
                style: "Clean, technical prose with environmental themes",
                plot: "Marine researcher races to save ocean ecosystems",
                characters: "Tide (driver) - Marine biologist turned eco-warrior racer",
                conflict: "Racing against time and pollution to save marine life",
                theme: "Environmental stewardship",
                pov: "Multiple perspectives including sea creatures",
                dialogue: "Scientific precision mixed with environmental passion",
                symbolism: "Cyan represents both water purity and technological harmony",
                story: "Dr. Tide left their research lab when they realized racing could raise more awareness for ocean conservation.",
                odds: "5:1",
                skill: 0.72,
                personality: "smooth"
            },
            {
                id: 6,
                name: "Solar Flare",
                color: "#ffa544",
                genre: "Space Opera",
                tone: "Grand and adventurous",
                setting: "Solar system-spanning race courses",
                style: "Expansive descriptions of cosmic phenomena",
                plot: "Interplanetary courier races to prevent galactic war",
                characters: "Nova (driver) - Former space freighter pilot",
                conflict: "Navigating political tensions while racing through asteroid fields",
                theme: "Communication across vast distances",
                pov: "Galactic historian documenting events",
                dialogue: "Multiple alien languages and translation protocols",
                symbolism: "Orange represents solar energy and life-giving warmth",
                story: "When the outer colonies stopped communicating, Nova volunteered for the most dangerous job in the galaxy.",
                odds: "4:1",
                skill: 0.78,
                personality: "risky"
            },
            {
                id: 7,
                name: "Cosmic Void",
                color: "#a544ff",
                genre: "Cosmic Horror",
                tone: "Ominous and surreal",
                setting: "Racing tracks that exist between dimensions",
                style: "Dreamlike descriptions with reality distortions",
                plot: "Reluctant racer prevents eldritch entities from entering reality",
                characters: "Void (driver) - Guardian cursed with forbidden knowledge",
                conflict: "Maintaining sanity while racing against cosmic horrors",
                theme: "Sacrifice for unknowing masses",
                pov: "Fragmented consciousness struggling with cosmic truth",
                dialogue: "Whispered warnings and half-remembered prophecies",
                symbolism: "Purple void represents the space between what is and what must never be",
                story: "Void races not for glory or prize money, but because someone must guard the thin places where reality grows weak.",
                odds: "8:1",
                skill: 0.55,
                personality: "erratic"
            }
        ];

        class RacingGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                this.gameState = 'betting'; // betting, racing, finished
                this.frameCount = 0;
                this.startTime = 0;
                this.raceNumber = 1;
                this.raceDistance = 3; // 3 laps
                
                this.cars = [];
                this.track = this.generateTrack();
                this.previousPositions = [];
                this.commentary = [];
                this.lastCommentaryTime = 0;
                
                this.playerMoney = 1000;
                this.currentBet = null;
                this.betAmount = 0;
                this.selectedTeam = null;
                
                this.setupUI();
                this.setupCars();
                this.updateTeamsList();
                this.addCommentary("Welcome to the Championship Racing Circuit! Place your bets!");
                this.gameLoop();
            }
            
            setupCanvas() {
                this.canvas.width = 800;
                this.canvas.height = 600;
            }
            
            generateTrack() {
                // Create a proper racing circuit with multiple turns
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                const trackPoints = [
                    // Start/finish straight
                    { x: width * 0.15, y: height * 0.5 },
                    { x: width * 0.35, y: height * 0.5 },
                    
                    // First turn complex
                    { x: width * 0.55, y: height * 0.5 },
                    { x: width * 0.75, y: height * 0.35 },
                    { x: width * 0.85, y: height * 0.15 },
                    
                    // Back straight
                    { x: width * 0.75, y: height * 0.1 },
                    { x: width * 0.35, y: height * 0.1 },
                    
                    // Hairpin turn
                    { x: width * 0.15, y: height * 0.15 },
                    { x: width * 0.1, y: height * 0.35 },
                    
                    // Technical section
                    { x: width * 0.15, y: height * 0.55 },
                    { x: width * 0.25, y: height * 0.75 },
                    { x: width * 0.45, y: height * 0.85 },
                    { x: width * 0.65, y: height * 0.75 },
                    { x: width * 0.75, y: height * 0.55 },
                    
                    // Final turn back to start
                    { x: width * 0.65, y: height * 0.45 },
                    { x: width * 0.45, y: height * 0.45 },
                    { x: width * 0.25, y: height * 0.48 }
                ];
                
                // Generate racing line checkpoints
                const checkpoints = [];
                for (let i = 0; i < trackPoints.length; i++) {
                    checkpoints.push({
                        x: trackPoints[i].x,
                        y: trackPoints[i].y,
                        angle: this.calculateAngle(trackPoints, i)
                    });
                }
                
                return {
                    points: trackPoints,
                    checkpoints: checkpoints,
                    width: 60
                };
            }
            
            calculateAngle(points, index) {
                const current = points[index];
                const next = points[(index + 1) % points.length];
                return Math.atan2(next.y - current.y, next.x - current.x);
            }
            
            setupCars() {
                this.cars = [];
                
                teams.forEach((team, i) => {
                    const startPoint = this.track.checkpoints[0];
                    const offsetX = (i % 4 - 1.5) * 15;
                    const offsetY = Math.floor(i / 4) * 20;
                    
                    // Add balanced randomization to skills
                    const baseSkill = team.skill;
                    const raceSkill = Math.max(0.3, Math.min(0.95, 
                        baseSkill + (Math.random() - 0.5) * 0.4)); // ¬±20% variance
                    
                    const car = {
                        id: team.id,
                        team: team,
                        x: startPoint.x + offsetX,
                        y: startPoint.y + offsetY,
                        vx: 0,
                        vy: 0,
                        angle: startPoint.angle,
                        speed: 0,
                        maxSpeed: 2.5 + raceSkill * 1.5 + Math.random() * 0.5,
                        acceleration: 0.15 + raceSkill * 0.1,
                        friction: 0.97,
                        turnSpeed: 0.03 + raceSkill * 0.02,
                        color: team.color,
                        lap: 0,
                        checkpointIndex: 0,
                        position: i + 1,
                        previousPosition: i + 1,
                        onTrack: true,
                        aiTarget: 1,
                        raceTime: 0,
                        finished: false,
                        finishTime: 0,
                        raceSkill: raceSkill,
                        personality: team.personality,
                        boostTime: 0,
                        lastCheckpointTime: Date.now()
                    };
                    this.cars.push(car);
                });
                
                this.previousPositions = this.cars.map(car => car.position);
            }
            
            setupUI() {
                document.getElementById('startRaceBtn').addEventListener('click', () => {
                    if (this.gameState === 'betting') {
                        this.startRace();
                    }
                });
                
                document.getElementById('placeBetBtn').addEventListener('click', () => {
                    this.placeBet();
                });
                
                document.getElementById('betAmount').addEventListener('input', (e) => {
                    this.updateBetButton();
                });
            }
            
            updateTeamsList() {
                const teamsList = document.getElementById('teamsList');
                teamsList.innerHTML = '';
                
                teams.forEach(team => {
                    const teamCard = document.createElement('div');
                    teamCard.className = 'team-card';
                    teamCard.style.borderLeftColor = team.color;
                    teamCard.onclick = () => this.selectTeam(team);
                    teamCard.ondblclick = () => this.showStory(team);
                    
                    teamCard.innerHTML = `
                        <div class="team-name" style="color: ${team.color}">${team.name}</div>
                        <div class="team-story">${team.story}</div>
                        <div class="team-odds">Odds: ${team.odds} | Skill: ${Math.round(team.skill * 100)}%</div>
                    `;
                    
                    teamsList.appendChild(teamCard);
                });
                
                this.updateBetButton();
            }
            
            selectTeam(team) {
                this.selectedTeam = team;
                
                // Update visual selection
                document.querySelectorAll('.team-card').forEach(card => {
                    card.classList.remove('selected');
                });
                event.target.closest('.team-card').classList.add('selected');
                
                this.updateBetButton();
            }
            
            updateBetButton() {
                const betBtn = document.getElementById('placeBetBtn');
                const betAmount = parseInt(document.getElementById('betAmount').value) || 0;
                
                if (this.selectedTeam && betAmount >= 10 && betAmount <= this.playerMoney && !this.currentBet) {
                    betBtn.disabled = false;
                    betBtn.textContent = `Bet $${betAmount} on ${this.selectedTeam.name}`;
                } else if (this.currentBet) {
                    betBtn.disabled = true;
                    betBtn.textContent = 'Bet Placed';
                } else {
                    betBtn.disabled = true;
                    betBtn.textContent = 'Select Team & Amount';
                }
            }
            
            placeBet() {
                if (!this.selectedTeam) return;
                
                const betAmount = parseInt(document.getElementById('betAmount').value) || 0;
                if (betAmount < 10 || betAmount > this.playerMoney) return;
                
                this.currentBet = {
                    team: this.selectedTeam,
                    amount: betAmount
                };
                
                this.playerMoney -= betAmount;
                document.getElementById('money').textContent = this.playerMoney;
                document.getElementById('currentBet').innerHTML = `
                    üéØ Bet: $${betAmount} on <span style="color: ${this.selectedTeam.color}">${this.selectedTeam.name}</span>
                `;
                
                this.addCommentary(`${this.selectedTeam.name} receives a $${betAmount} bet from the crowd!`);
                this.updateBetButton();
            }
            
            showStory(team) {
                const storyContent = document.getElementById('storyContent');
                storyContent.innerHTML = `
                    <h2 style="color: ${team.color}; text-align: center; margin-bottom: 20px;">${team.name}</h2>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div><strong>Genre:</strong> ${team.genre}</div>
                        <div><strong>Tone:</strong> ${team.tone}</div>
                        <div><strong>Setting:</strong> ${team.setting}</div>
                        <div><strong>Style:</strong> ${team.style}</div>
                        <div><strong>Point of View:</strong> ${team.pov}</div>
                        <div><strong>Theme:</strong> ${team.theme}</div>
                    </div>
                    
                    <h3>Plot</h3>
                    <p style="margin-bottom: 15px;">${team.plot}</p>
                    
                    <h3>Characters</h3>
                    <p style="margin-bottom: 15px;">${team.characters}</p>
                    
                    <h3>Team Story</h3>
                    <p style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; border-left: 4px solid ${team.color};">
                        ${team.story}
                    </p>
                `;
                
                document.getElementById('storyDetails').style.display = 'block';
            }
            
            startRace() {
                this.gameState = 'racing';
                this.startTime = Date.now();
                document.getElementById('raceStatus').textContent = 'Racing!';
                
                // Reset car positions
                this.setupCars();
                this.addCommentary("üèÅ AND THEY'RE OFF! The race has begun!");
            }
            
            addCommentary(text) {
                const now = Date.now();
                if (now - this.lastCommentaryTime < 1000) return; // Limit commentary frequency
                
                this.commentary.push({
                    text: text,
                    time: now
                });
                
                // Keep only last 10 comments
                if (this.commentary.length > 10) {
                    this.commentary.shift();
                }
                
                this.updateCommentaryDisplay();
                this.lastCommentaryTime = now;
            }
            
            updateCommentaryDisplay() {
                const feed = document.getElementById('commentaryFeed');
                feed.innerHTML = this.commentary.map(comment => 
                    `<div class="commentary-line">${comment.text}</div>`
                ).join('');
                feed.scrollTop = feed.scrollHeight;
            }
            
            updateAICar(car) {
                if (car.finished) return;
                
                const targetCheckpoint = this.track.checkpoints[car.aiTarget];
                const dx = targetCheckpoint.x - car.x;
                const dy = targetCheckpoint.y - car.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const targetAngle = Math.atan2(dy, dx);
                
                // Check if reached target checkpoint
                if (distance < 25) {
                    car.aiTarget = (car.aiTarget + 1) % this.track.checkpoints.length;
                    if (car.aiTarget === 0) {
                        car.lap++;
                        this.addCommentary(`${car.team.name} completes lap ${car.lap}!`);
                        if (car.lap >= this.raceDistance && !car.finished) {
                            car.finished = true;
                            car.finishTime = Date.now() - this.startTime;
                            this.addCommentary(`üèÅ ${car.team.name} crosses the finish line!`);
                        }
                    }
                    car.lastCheckpointTime = Date.now();
                }
                
                // Personality-based driving with balanced randomization
                let speedModifier = 1.0;
                let riskFactor = 1.0;
                
                // Base personality effects (reduced for balance)
                switch (car.personality) {
                    case "aggressive":
                        speedModifier = 1.0 + Math.random() * 0.1;
                        riskFactor = 1.05;
                        break;
                    case "technical":
                        speedModifier = 1.02;
                        riskFactor = 0.95;
                        break;
                    case "steady":
                        speedModifier = 1.0;
                        riskFactor = 1.0;
                        break;
                    case "underdog":
                        // Gets stronger as race progresses
                        speedModifier = 0.95 + (car.lap * 0.03);
                        riskFactor = 1.02;
                        break;
                    case "mystical":
                        speedModifier = 0.98 + Math.sin(this.frameCount * 0.02) * 0.08;
                        riskFactor = 1.0;
                        break;
                    case "smooth":
                        speedModifier = 1.03;
                        riskFactor = 0.98;
                        break;
                    case "risky":
                        speedModifier = 1.05 + Math.random() * 0.1 - 0.05;
                        riskFactor = 1.1;
                        break;
                    case "erratic":
                        speedModifier = 0.9 + Math.random() * 0.2;
                        riskFactor = 1.0 + Math.random() * 0.1;
                        break;
                }
                
                // Rubber band AI - cars in back get slight boost
                if (car.position > 4) {
                    speedModifier *= 1.05;
                }
                
                // Calculate effective speed
                const effectiveSkill = car.raceSkill * speedModifier;
                const targetSpeed = car.maxSpeed * effectiveSkill * riskFactor;
                
                // Steering towards target with some variance
                let angleDiff = targetAngle - car.angle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                car.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), car.turnSpeed);
                
                // Speed control with some randomness
                const speedVariance = (Math.random() - 0.5) * 0.1;
                const adjustedTargetSpeed = targetSpeed * (1 + speedVariance);
                
                if (car.speed < adjustedTargetSpeed) {
                    car.speed += car.acceleration;
                } else {
                    car.speed *= car.friction;
                }
                
                // Apply movement
                car.vx = Math.cos(car.angle) * car.speed;
                car.vy = Math.sin(car.angle) * car.speed;
                car.x += car.vx;
                car.y += car.vy;
                
                // Keep cars roughly on track
                const nearestTrackPoint = this.findNearestTrackPoint(car.x, car.y);
                const trackDistance = Math.sqrt(
                    (car.x - nearestTrackPoint.x) ** 2 + 
                    (car.y - nearestTrackPoint.y) ** 2
                );
                
                if (trackDistance > this.track.width) {
                    car.speed *= 0.9; // Slow down when off track
                    // Gently guide back to track
                    const pushAngle = Math.atan2(
                        nearestTrackPoint.y - car.y,
                        nearestTrackPoint.x - car.x
                    );
                    car.x += Math.cos(pushAngle) * 2;
                    car.y += Math.sin(pushAngle) * 2;
                }
            }
            
            findNearestTrackPoint(x, y) {
                let nearest = this.track.points[0];
                let minDistance = Infinity;
                
                for (let point of this.track.points) {
                    const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = point;
                    }
                }
                
                return nearest;
            }
            
            updatePositions() {
                // Sort cars by race progress
                this.cars.sort((a, b) => {
                    if (a.finished && !b.finished) return -1;
                    if (!a.finished && b.finished) return 1;
                    if (a.finished && b.finished) return a.finishTime - b.finishTime;
                    
                    if (a.lap !== b.lap) return b.lap - a.lap;
                    
                    if (a.aiTarget !== b.aiTarget) return b.aiTarget - a.aiTarget;
                    
                    // Same checkpoint, compare distance to next checkpoint
                    const aTarget = this.track.checkpoints[a.aiTarget];
                    const bTarget = this.track.checkpoints[b.aiTarget];
                    const aDist = Math.sqrt((a.x - aTarget.x) ** 2 + (a.y - aTarget.y) ** 2);
                    const bDist = Math.sqrt((b.x - bTarget.x) ** 2 + (b.y - bTarget.y) ** 2);
                    
                    return aDist - bDist;
                });
                
                // Update positions and track changes
                this.cars.forEach((car, index) => {
                    car.previousPosition = car.position;
                    car.position = index + 1;
                });
                
                // Generate position change commentary
                this.cars.forEach(car => {
                    if (car.previousPosition !== car.position) {
                        if (car.position < car.previousPosition) {
                            this.addCommentary(`üìà ${car.team.name} moves up to position ${car.position}!`);
                        } else {
                            this.addCommentary(`üìâ ${car.team.name} drops to position ${car.position}`);
                        }
                    }
                });
                
                // Update leaderboard display
                this.updateLeaderboardDisplay();
            }
            
            updateLeaderboardDisplay() {
                const positionsDiv = document.getElementById('positions');
                positionsDiv.innerHTML = this.cars.map((car, index) => {
                    const status = car.finished ? 'FINISHED' : `Lap ${car.lap + 1}/${this.raceDistance}`;
                    
                    let changeIcon = '';
                    let changeClass = 'position-same';
                    if (car.position < car.previousPosition) {
                        changeIcon = '‚ñ≤';
                        changeClass = 'position-up';
                    } else if (car.position > car.previousPosition) {
                        changeIcon = '‚ñº';
                        changeClass = 'position-down';
                    } else {
                        changeIcon = '=';
                    }
                    
                    return `<div class="position-item">
                        <span class="position-number" style="color: ${car.color}">${index + 1}.</span>
                        <span style="color: ${car.color}; flex-grow: 1;">${car.team.name}</span>
                        <span class="position-change ${changeClass}">${changeIcon}</span>
                        <span style="font-size: 10px; color: #888;">${status}</span>
                    </div>`;
                }).join('');
            }
            
            checkRaceComplete() {
                const finishedCars = this.cars.filter(car => car.finished);
                if (finishedCars.length === this.cars.length || 
                   (finishedCars.length > 0 && Date.now() - this.startTime > 90000)) {
                    this.gameState = 'finished';
                    this.showRaceResults();
                }
            }
            
            showRaceResults() {
                const winner = this.cars.find(car => car.position === 1);
                const winnerAnnouncement = document.getElementById('winnerAnnouncement');
                const payoutInfo = document.getElementById('payoutInfo');
                
                winnerAnnouncement.innerHTML = `
                    <h3 style="color: ${winner.color}">üèÜ ${winner.team.name} WINS!</h3>
                    <p>Race Time: ${this.formatTime(winner.finishTime || Date.now() - this.startTime)}</p>
                `;
                
                this.addCommentary(`üèÜ RACE COMPLETE! ${winner.team.name} takes the checkered flag!`);
                
                let payoutText = '';
                if (this.currentBet && this.currentBet.team.id === winner.id) {
                    const odds = parseFloat(this.currentBet.team.odds.split(':')[0]);
                    const payout = this.currentBet.amount * odds;
                    this.playerMoney += payout;
                    payoutText = `üéâ YOU WON! Payout: $${payout}`;
                    document.getElementById('money').textContent = this.playerMoney;
                } else if (this.currentBet) {
                    payoutText = `üòû You lost your bet on ${this.currentBet.team.name}`;
                } else {
                    payoutText = `No bet placed this race`;
                }
                
                payoutInfo.innerHTML = payoutText;
                document.getElementById('raceResults').style.display = 'block';
            }
            
            formatTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                const remainingMs = ms % 1000;
                return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}.${Math.floor(remainingMs / 100)}`;
            }
            
            drawTrack() {
                const ctx = this.ctx;
                
                // Draw grass background
                ctx.fillStyle = '#2a5a2a';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw track surface
                ctx.strokeStyle = '#333';
                ctx.lineWidth = this.track.width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(this.track.points[0].x, this.track.points[0].y);
                
                for (let i = 1; i < this.track.points.length; i++) {
                    ctx.lineTo(this.track.points[i].x, this.track.points[i].y);
                }
                ctx.closePath();
                ctx.stroke();
                
                // Draw track borders
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Draw track center line
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw start/finish line
                const startPoint = this.track.points[0];
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(startPoint.x - 30, startPoint.y - 15);
                ctx.lineTo(startPoint.x + 30, startPoint.y + 15);
                ctx.stroke();
                
                // Draw checkpoints
                this.track.checkpoints.forEach((checkpoint, i) => {
                    ctx.fillStyle = i === 0 ? '#FFD700' : '#fff';
                    ctx.beginPath();
                    ctx.arc(checkpoint.x, checkpoint.y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    if (i === 0) {
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText('START/FINISH', checkpoint.x - 50, checkpoint.y - 25);
                    }
                });
            }
            
            drawCars() {
                this.cars.forEach(car => {
                    const ctx = this.ctx;
                    
                    ctx.save();
                    ctx.translate(car.x, car.y);
                    ctx.rotate(car.angle);
                    
                    // Car body
                    ctx.fillStyle = car.color;
                    ctx.fillRect(-8, -4, 16, 8);
                    
                    // Car outline
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-8, -4, 16, 8);
                    
                    // Position number
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(car.position.toString(), 0, 3);
                    
                    ctx.restore();
                    
                    // Speed trail effect
                    if (car.speed > 1.5) {
                        ctx.save();
                        ctx.globalAlpha = 0.4;
                        ctx.strokeStyle = car.color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(car.x, car.y);
                        ctx.lineTo(
                            car.x - car.vx * 8,
                            car.y - car.vy * 8
                        );
                        ctx.stroke();
                        ctx.restore();
                    }
                });
            }
            
            updateTimer() {
                if (this.gameState === 'racing') {
                    const elapsed = Date.now() - this.startTime;
                    document.getElementById('timer').textContent = this.formatTime(elapsed);
                }
            }
            
            gameLoop() {
                this.frameCount++;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw everything
                this.drawTrack();
                this.drawCars();
                
                // Update game state
                if (this.gameState === 'racing') {
                    this.cars.forEach(car => this.updateAICar(car));
                    this.updatePositions();
                    this.updateTimer();
                    this.checkRaceComplete();
                }
                
                // Continue game loop
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Global functions
        function resetRace() {
            document.getElementById('raceResults').style.display = 'none';
            game.gameState = 'betting';
            game.raceNumber++;
            game.currentBet = null;
            game.selectedTeam = null;
            document.getElementById('raceNumber').textContent = game.raceNumber;
            document.getElementById('raceStatus').textContent = 'Betting Open';
            document.getElementById('currentBet').innerHTML = '';
            document.getElementById('timer').textContent = '0:00';
            
            // Clear team selections
            document.querySelectorAll('.team-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            game.updateBetButton();
            game.addCommentary(`üèÅ Welcome to Race ${game.raceNumber}! Place your bets!`);
        }
        
        function closeStory() {
            document.getElementById('storyDetails').style.display = 'none';
        }
        
        // Start the game
        let game;
        window.addEventListener('load', () => {
            game = new RacingGame();
        });
    </script>
</body>
</html>