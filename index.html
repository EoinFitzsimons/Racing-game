<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Championship Racing Bets</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
            color: white;
            min-height: 100vh;
        }

        #gameContainer {
            position: relative;
            max-width: 1200px;
            margin: 0 auto;
            background: #333;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        #gameCanvas {
            display: block;
            background: #2a5a2a;
            width: 100%;
            max-width: 800px;
            height: 600px;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 8px;
        }

        #bettingPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            min-width: 300px;
            max-height: 580px;
            overflow-y: auto;
            z-index: 15;
        }

        .team-card {
            background: rgba(255,255,255,0.1);
            margin: 8px 0;
            padding: 10px;
            border-radius: 8px;
            border-left: 4px solid;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .team-card:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }

        .team-card.selected {
            background: rgba(255,215,0,0.3);
            box-shadow: 0 0 15px rgba(255,215,0,0.5);
        }

        .team-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .team-story {
            font-size: 11px;
            color: #ccc;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .team-odds {
            font-size: 12px;
            color: #4CAF50;
            font-weight: bold;
        }

        #betControls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #555;
        }

        #betAmount {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
            color: white;
            text-align: center;
        }

        #placeBetBtn, #startRaceBtn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        #placeBetBtn:hover, #startRaceBtn:hover {
            background: #45a049;
        }

        #placeBetBtn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #wallet {
            background: rgba(255,215,0,0.2);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin-bottom: 10px;
            border: 1px solid #FFD700;
        }

        #raceResults {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 25;
            border: 2px solid #FFD700;
        }

        .story-details {
            background: rgba(0,0,0,0.8);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 40px;
            display: none;
            z-index: 30;
            overflow-y: auto;
        }

        .story-content {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255,255,255,0.1);
            padding: 30px;
            border-radius: 15px;
        }

        .close-story {
            position: absolute;
            top: 20px;
            right: 30px;
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
        }

        #leaderboard {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 8px;
            min-width: 200px;
        }

        .position-item {
            margin: 3px 0;
            font-size: 12px;
        }

        @media (max-width: 768px) {
            #bettingPanel {
                position: relative;
                width: 100%;
                max-height: none;
                margin-top: 10px;
            }
            
            #gameContainer {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div>Race: <span id="raceNumber">1</span></div>
            <div>Time: <span id="timer">0:00</span></div>
            <div>Status: <span id="raceStatus">Betting Open</span></div>
        </div>

        <div id="bettingPanel">
            <div id="wallet">
                üí∞ Wallet: $<span id="money">1000</span>
            </div>
            
            <h3 style="text-align: center; margin-bottom: 15px;">üèÅ Championship Teams</h3>
            
            <div id="teamsList"></div>
            
            <div id="betControls">
                <input type="number" id="betAmount" placeholder="Bet Amount" min="10" max="1000" value="50">
                <button id="placeBetBtn" disabled>Place Bet</button>
                <button id="startRaceBtn">Start Race!</button>
            </div>
            
            <div id="currentBet" style="margin-top: 10px; font-size: 12px; color: #FFD700;"></div>
        </div>

        <div id="leaderboard">
            <div style="font-weight: bold; margin-bottom: 5px;">üèÜ Live Positions</div>
            <div id="positions"></div>
        </div>

        <div id="raceResults">
            <h2>üèÅ Race Complete!</h2>
            <div id="winnerAnnouncement"></div>
            <div id="payoutInfo"></div>
            <button onclick="resetRace()" style="margin-top: 20px; padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Next Race</button>
        </div>

        <div id="storyDetails" class="story-details">
            <button class="close-story" onclick="closeStory()">‚úï</button>
            <div class="story-content" id="storyContent"></div>
        </div>
    </div>

    <script>
        // Team stories and data
        const teams = [
            {
                id: 0,
                name: "Crimson Shadows",
                color: "#ff4444",
                genre: "Dark Fantasy",
                tone: "Mysterious and intense",
                setting: "Underground racing circuits in a post-apocalyptic cityscape",
                style: "Gritty realism with supernatural elements",
                plot: "Former street racers turned shadow operatives seeking redemption",
                characters: "Raven (driver) - A reformed criminal with photographic memory for racing lines",
                conflict: "Battling inner demons while racing to fund an orphanage",
                theme: "Redemption through sacrifice",
                pov: "Third person limited (Raven's perspective)",
                dialogue: "Terse, meaningful exchanges laden with subtext",
                symbolism: "Red represents both blood and rebirth",
                story: "Born from the ashes of the Great Circuit Wars, Crimson Shadows emerged when underground racer 'Raven' discovered their illegal winnings were being used to fund a children's sanctuary. Now they race not for glory, but to keep hope alive in the darkest corners of the city.",
                odds: "4:1",
                skill: 0.85
            },
            {
                id: 1,
                name: "Neon Velocity",
                color: "#44ff44",
                genre: "Cyberpunk",
                tone: "Electric and rebellious",
                setting: "Neo-Tokyo 2087, holographic racing circuits",
                style: "High-tech prose with rapid-fire pacing",
                plot: "Corporate hacker races to expose mega-corp corruption",
                characters: "Zap (driver) - Augmented street racer with neural implants",
                conflict: "Evading corporate assassins while maintaining racing performance",
                theme: "Technology vs. humanity",
                pov: "Second person (You are the rebellion)",
                dialogue: "Tech-heavy slang mixed with philosophical observations",
                symbolism: "Green light represents the digital frontier and freedom",
                story: "In the neon-soaked streets of Neo-Tokyo, Zap races with illegal neural mods that sync directly with their vehicle. Each victory is a hack against the corporate overlords, each lap a statement that the human spirit cannot be digitized or controlled.",
                odds: "3:1",
                skill: 0.90
            },
            {
                id: 2,
                name: "Azure Lightning",
                color: "#4444ff",
                genre: "Epic Adventure",
                tone: "Heroic and inspiring",
                setting: "Floating sky cities connected by storm clouds",
                style: "Lyrical and grandiose",
                plot: "Sky pirate seeks to unite the fractured aerial kingdoms",
                characters: "Storm (driver) - Noble sky pirate with a heart of gold",
                conflict: "Overcoming political intrigue while mastering storm-riding",
                theme: "Unity through adversity",
                pov: "Omniscient narrator celebrating heroic deeds",
                dialogue: "Formal speech patterns with nautical terminology",
                symbolism: "Blue represents both sky freedom and royal nobility",
                story: "Captain Storm once commanded the fastest cloudship in the Seven Skies until politics grounded their fleet. Now they race through tempests and lightning, seeking to prove that honor and speed can reunite the fractured sky kingdoms under one banner.",
                odds: "5:1",
                skill: 0.80
            },
            {
                id: 3,
                name: "Golden Eagles",
                color: "#ffff44",
                genre: "Sports Drama",
                tone: "Triumphant and emotional",
                setting: "International racing academies and championship circuits",
                style: "Inspirational with focus on personal growth",
                plot: "Underdog team fights for recognition in elite racing circles",
                characters: "Phoenix (driver) - Small-town racer with big dreams",
                conflict: "Overcoming class prejudice and financial limitations",
                theme: "Dreams transcend circumstances",
                pov: "First person (Phoenix's journal entries)",
                dialogue: "Heartfelt conversations about hopes and fears",
                symbolism: "Gold represents both wealth aspired to and inner worth discovered",
                story: "From a small farming town, Phoenix learned to race on dusty back roads with a hand-me-down vehicle. Every championship lap is a love letter to their hometown, proving that golden hearts matter more than golden wallets.",
                odds: "6:1",
                skill: 0.75
            },
            {
                id: 4,
                name: "Violet Storm",
                color: "#ff44ff",
                genre: "Magical Realism",
                tone: "Mystical and contemplative",
                setting: "Ancient racing grounds where reality bends",
                style: "Flowing prose with unexpected magical elements",
                plot: "Mystical racer channels elemental forces to break ancient curses",
                characters: "Mystic (driver) - Seer who races between dimensions",
                conflict: "Balancing magical duties with mortal competition",
                theme: "Balance between worlds",
                pov: "Stream of consciousness with mystical insights",
                dialogue: "Poetic speech that hints at deeper meanings",
                symbolism: "Purple bridges the physical and spiritual realms",
                story: "Legend speaks of a racer who sees the wind before it blows and knows the track before it's built. Mystic races not just against opponents, but against fate itself, weaving through reality's thin spots to protect both worlds from chaos.",
                odds: "7:1",
                skill: 0.70
            },
            {
                id: 5,
                name: "Aqua Titans",
                color: "#44ffff",
                genre: "Science Fiction",
                tone: "Sleek and progressive",
                setting: "Underwater cities and submarine racing tubes",
                style: "Clean, technical prose with environmental themes",
                plot: "Marine researcher races to save ocean ecosystems",
                characters: "Tide (driver) - Marine biologist turned eco-warrior racer",
                conflict: "Racing against time and pollution to save marine life",
                theme: "Environmental stewardship",
                pov: "Multiple perspectives including sea creatures",
                dialogue: "Scientific precision mixed with environmental passion",
                symbolism: "Cyan represents both water purity and technological harmony",
                story: "Dr. Tide left their research lab when they realized racing could raise more awareness for ocean conservation than any paper ever could. Every victory funds another reef restoration, every sponsor dollar becomes another protected marine sanctuary.",
                odds: "5:1",
                skill: 0.82
            },
            {
                id: 6,
                name: "Solar Flare",
                color: "#ffa544",
                genre: "Space Opera",
                tone: "Grand and adventurous",
                setting: "Solar system-spanning race courses",
                style: "Expansive descriptions of cosmic phenomena",
                plot: "Interplanetary courier races to prevent galactic war",
                characters: "Nova (driver) - Former space freighter pilot",
                conflict: "Navigating political tensions while racing through asteroid fields",
                theme: "Communication across vast distances",
                pov: "Galactic historian documenting events",
                dialogue: "Multiple alien languages and translation protocols",
                symbolism: "Orange represents solar energy and life-giving warmth",
                story: "When the outer colonies stopped communicating, Nova volunteered for the most dangerous job in the galaxy: racing diplomatic messages through pirate-infested space. Each delivery prevents wars, each victory saves worlds from silence.",
                odds: "4:1",
                skill: 0.88
            },
            {
                id: 7,
                name: "Cosmic Void",
                color: "#a544ff",
                genre: "Cosmic Horror",
                tone: "Ominous and surreal",
                setting: "Racing tracks that exist between dimensions",
                style: "Dreamlike descriptions with reality distortions",
                plot: "Reluctant racer prevents eldritch entities from entering reality",
                characters: "Void (driver) - Guardian cursed with forbidden knowledge",
                conflict: "Maintaining sanity while racing against cosmic horrors",
                theme: "Sacrifice for unknowing masses",
                pov: "Fragmented consciousness struggling with cosmic truth",
                dialogue: "Whispered warnings and half-remembered prophecies",
                symbolism: "Purple void represents the space between what is and what must never be",
                story: "Void races not for glory or prize money, but because someone must guard the thin places where reality grows weak. Each lap seals another crack in the universe, each victory postpones an apocalypse that spectators will never know they avoided.",
                odds: "8:1",
                skill: 0.65
            }
        ];

        class RacingGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                this.gameState = 'betting'; // betting, racing, finished
                this.frameCount = 0;
                this.startTime = 0;
                this.raceNumber = 1;
                this.raceDistance = 3; // 3 laps
                
                this.cars = [];
                this.track = this.generateTrack();
                
                this.playerMoney = 1000;
                this.currentBet = null;
                this.betAmount = 0;
                this.selectedTeam = null;
                
                this.setupUI();
                this.setupCars();
                this.updateTeamsList();
                this.gameLoop();
            }
            
            setupCanvas() {
                this.canvas.width = 800;
                this.canvas.height = 600;
            }
            
            generateTrack() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radiusOuter = Math.min(centerX, centerY) - 50;
                const radiusInner = radiusOuter - 80;
                
                return {
                    centerX,
                    centerY,
                    radiusOuter,
                    radiusInner,
                    checkpoints: this.generateCheckpoints(centerX, centerY, (radiusOuter + radiusInner) / 2)
                };
            }
            
            generateCheckpoints(centerX, centerY, radius) {
                const checkpoints = [];
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    checkpoints.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius,
                        angle: angle
                    });
                }
                return checkpoints;
            }
            
            setupCars() {
                const startRadius = (this.track.radiusOuter + this.track.radiusInner) / 2;
                this.cars = [];
                
                teams.forEach((team, i) => {
                    const startAngle = -Math.PI / 2 + (i * 0.1);
                    const car = {
                        id: team.id,
                        team: team,
                        x: this.track.centerX + Math.cos(startAngle) * startRadius,
                        y: this.track.centerY + Math.sin(startAngle) * startRadius,
                        vx: 0,
                        vy: 0,
                        angle: startAngle + Math.PI / 2,
                        speed: 0,
                        maxSpeed: 3 + team.skill * 2 + Math.random() * 0.5,
                        acceleration: 0.2 + team.skill * 0.1,
                        friction: 0.98,
                        turnSpeed: 0.04 + team.skill * 0.02,
                        color: team.color,
                        lap: 0,
                        checkpointIndex: 0,
                        position: i + 1,
                        onTrack: true,
                        aiTarget: 0,
                        raceTime: 0,
                        finished: false,
                        finishTime: 0
                    };
                    this.cars.push(car);
                });
            }
            
            setupUI() {
                document.getElementById('startRaceBtn').addEventListener('click', () => {
                    if (this.gameState === 'betting') {
                        this.startRace();
                    }
                });
                
                document.getElementById('placeBetBtn').addEventListener('click', () => {
                    this.placeBet();
                });
                
                document.getElementById('betAmount').addEventListener('input', (e) => {
                    this.updateBetButton();
                });
            }
            
            updateTeamsList() {
                const teamsList = document.getElementById('teamsList');
                teamsList.innerHTML = '';
                
                teams.forEach(team => {
                    const teamCard = document.createElement('div');
                    teamCard.className = 'team-card';
                    teamCard.style.borderLeftColor = team.color;
                    teamCard.onclick = () => this.selectTeam(team);
                    teamCard.ondblclick = () => this.showStory(team);
                    
                    teamCard.innerHTML = `
                        <div class="team-name" style="color: ${team.color}">${team.name}</div>
                        <div class="team-story">${team.story}</div>
                        <div class="team-odds">Odds: ${team.odds} | Skill: ${Math.round(team.skill * 100)}%</div>
                        <div style="font-size: 10px; color: #888; margin-top: 5px;">Double-click for full story</div>
                    `;
                    
                    teamsList.appendChild(teamCard);
                });
                
                this.updateBetButton();
            }
            
            selectTeam(team) {
                this.selectedTeam = team;
                
                // Update visual selection
                document.querySelectorAll('.team-card').forEach(card => {
                    card.classList.remove('selected');
                });
                event.target.closest('.team-card').classList.add('selected');
                
                this.updateBetButton();
            }
            
            updateBetButton() {
                const betBtn = document.getElementById('placeBetBtn');
                const betAmount = parseInt(document.getElementById('betAmount').value) || 0;
                
                if (this.selectedTeam && betAmount >= 10 && betAmount <= this.playerMoney && !this.currentBet) {
                    betBtn.disabled = false;
                    betBtn.textContent = `Bet $${betAmount} on ${this.selectedTeam.name}`;
                } else if (this.currentBet) {
                    betBtn.disabled = true;
                    betBtn.textContent = 'Bet Placed';
                } else {
                    betBtn.disabled = true;
                    betBtn.textContent = 'Select Team & Amount';
                }
            }
            
            placeBet() {
                if (!this.selectedTeam) return;
                
                const betAmount = parseInt(document.getElementById('betAmount').value) || 0;
                if (betAmount < 10 || betAmount > this.playerMoney) return;
                
                this.currentBet = {
                    team: this.selectedTeam,
                    amount: betAmount
                };
                
                this.playerMoney -= betAmount;
                document.getElementById('money').textContent = this.playerMoney;
                document.getElementById('currentBet').innerHTML = `
                    üéØ Bet: $${betAmount} on <span style="color: ${this.selectedTeam.color}">${this.selectedTeam.name}</span>
                `;
                
                this.updateBetButton();
            }
            
            showStory(team) {
                const storyContent = document.getElementById('storyContent');
                storyContent.innerHTML = `
                    <h2 style="color: ${team.color}; text-align: center; margin-bottom: 20px;">${team.name}</h2>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div><strong>Genre:</strong> ${team.genre}</div>
                        <div><strong>Tone:</strong> ${team.tone}</div>
                        <div><strong>Setting:</strong> ${team.setting}</div>
                        <div><strong>Style:</strong> ${team.style}</div>
                        <div><strong>Point of View:</strong> ${team.pov}</div>
                        <div><strong>Theme:</strong> ${team.theme}</div>
                    </div>
                    
                    <h3>Plot</h3>
                    <p style="margin-bottom: 15px;">${team.plot}</p>
                    
                    <h3>Characters</h3>
                    <p style="margin-bottom: 15px;">${team.characters}</p>
                    
                    <h3>Conflict</h3>
                    <p style="margin-bottom: 15px;">${team.conflict}</p>
                    
                    <h3>Dialogue Style</h3>
                    <p style="margin-bottom: 15px;">${team.dialogue}</p>
                    
                    <h3>Symbolism</h3>
                    <p style="margin-bottom: 15px;">${team.symbolism}</p>
                    
                    <h3>Team Story</h3>
                    <p style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; border-left: 4px solid ${team.color};">
                        ${team.story}
                    </p>
                `;
                
                document.getElementById('storyDetails').style.display = 'block';
            }
            
            startRace() {
                this.gameState = 'racing';
                this.startTime = Date.now();
                document.getElementById('raceStatus').textContent = 'Racing!';
                
                // Reset car positions
                this.setupCars();
            }
            
            updateAICar(car) {
                if (car.finished) return;
                
                // Enhanced AI with team personality
                const targetCheckpoint = this.track.checkpoints[car.aiTarget];
                const dx = targetCheckpoint.x - car.x;
                const dy = targetCheckpoint.y - car.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const targetAngle = Math.atan2(dy, dx);
                
                // Check if reached target checkpoint
                if (distance < 30) {
                    car.aiTarget = (car.aiTarget + 1) % this.track.checkpoints.length;
                    if (car.aiTarget === 0) {
                        car.lap++;
                        if (car.lap >= this.raceDistance && !car.finished) {
                            car.finished = true;
                            car.finishTime = Date.now() - this.startTime;
                        }
                    }
                }
                
                // Personality-based driving modifications
                let speedModifier = 1;
                let aggressionModifier = 1;
                
                switch (car.team.id) {
                    case 0: // Crimson Shadows - Aggressive but strategic
                        speedModifier = 1.1;
                        aggressionModifier = 1.2;
                        break;
                    case 1: // Neon Velocity - Tech-enhanced precision
                        speedModifier = 1.15;
                        aggressionModifier = 0.9;
                        break;
                    case 2: // Azure Lightning - Heroic consistency
                        speedModifier = 1.05;
                        aggressionModifier = 1.0;
                        break;
                    case 3: // Golden Eagles - Underdog determination
                        speedModifier = 0.95 + (car.lap * 0.05); // Gets faster each lap
                        aggressionModifier = 1.1;
                        break;
                    case 4: // Violet Storm - Mystical unpredictability
                        speedModifier = 0.9 + Math.sin(this.frameCount * 0.01) * 0.3;
                        aggressionModifier = 1.0;
                        break;
                    case 5: // Aqua Titans - Smooth and efficient
                        speedModifier = 1.08;
                        aggressionModifier = 0.8;
                        break;
                    case 6: // Solar Flare - Fast but risky
                        speedModifier = 1.12;
                        aggressionModifier = 1.3;
                        break;
                    case 7: // Cosmic Void - Erratic but powerful
                        speedModifier = 0.85 + Math.random() * 0.4;
                        aggressionModifier = 1.1;
                        break;
                }
                
                // Apply team skill and personality
                const effectiveSkill = car.team.skill * speedModifier;
                const targetSpeed = car.maxSpeed * effectiveSkill * aggressionModifier;
                
                // Steering towards target
                let angleDiff = targetAngle - car.angle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                car.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), car.turnSpeed);
                
                // Speed control
                if (car.speed < targetSpeed) {
                    car.speed += car.acceleration;
                } else {
                    car.speed *= car.friction;
                }
                
                // Apply movement
                car.vx = Math.cos(car.angle) * car.speed;
                car.vy = Math.sin(car.angle) * car.speed;
                car.x += car.vx;
                car.y += car.vy;
                
                // Track boundaries
                const distFromCenter = Math.sqrt(
                    (car.x - this.track.centerX) ** 2 + 
                    (car.y - this.track.centerY) ** 2
                );
                
                if (distFromCenter > this.track.radiusOuter - 10 || 
                    distFromCenter < this.track.radiusInner + 10) {
                    car.speed *= 0.8; // Slow down when hitting walls
                    
                    // Push back towards track
                    const pushAngle = Math.atan2(
                        car.y - this.track.centerY, 
                        car.x - this.track.centerX
                    );
                    
                    if (distFromCenter > this.track.radiusOuter - 10) {
                        car.x = this.track.centerX + Math.cos(pushAngle) * (this.track.radiusOuter - 15);
                        car.y = this.track.centerY + Math.sin(pushAngle) * (this.track.radiusOuter - 15);
                    } else {
                        car.x = this.track.centerX + Math.cos(pushAngle) * (this.track.radiusInner + 15);
                        car.y = this.track.centerY + Math.sin(pushAngle) * (this.track.radiusInner + 15);
                    }
                }
            }
            
            updatePositions() {
                // Sort cars by lap and progress
                this.cars.sort((a, b) => {
                    if (a.finished && !b.finished) return -1;
                    if (!a.finished && b.finished) return 1;
                    if (a.finished && b.finished) return a.finishTime - b.finishTime;
                    
                    if (a.lap !== b.lap) return b.lap - a.lap;
                    
                    // Same lap, compare checkpoint progress
                    if (a.checkpointIndex !== b.checkpointIndex) {
                        return b.checkpointIndex - a.checkpointIndex;
                    }
                    
                    // Same checkpoint, compare distance to next checkpoint
                    const aTarget = this.track.checkpoints[a.aiTarget];
                    const bTarget = this.track.checkpoints[b.aiTarget];
                    const aDist = Math.sqrt((a.x - aTarget.x) ** 2 + (a.y - aTarget.y) ** 2);
                    const bDist = Math.sqrt((b.x - bTarget.x) ** 2 + (b.y - bTarget.y) ** 2);
                    
                    return aDist - bDist;
                });
                
                // Update positions
                this.cars.forEach((car, index) => {
                    car.position = index + 1;
                });
                
                // Update leaderboard display
                const positionsDiv = document.getElementById('positions');
                positionsDiv.innerHTML = this.cars.map((car, index) => {
                    const status = car.finished ? 'FINISHED' : `Lap ${car.lap + 1}/${this.raceDistance}`;
                    return `<div class="position-item" style="color: ${car.color}">
                        ${index + 1}. ${car.team.name} - ${status}
                    </div>`;
                }).join('');
            }
            
            checkRaceComplete() {
                const finishedCars = this.cars.filter(car => car.finished);
                if (finishedCars.length === this.cars.length || finishedCars.length > 0 && Date.now() - this.startTime > 60000) {
                    this.gameState = 'finished';
                    this.showRaceResults();
                }
            }
            
            showRaceResults() {
                const winner = this.cars.find(car => car.position === 1);
                const winnerAnnouncement = document.getElementById('winnerAnnouncement');
                const payoutInfo = document.getElementById('payoutInfo');
                
                winnerAnnouncement.innerHTML = `
                    <h3 style="color: ${winner.color}">üèÜ ${winner.team.name} WINS!</h3>
                    <p>Race Time: ${this.formatTime(winner.finishTime || Date.now() - this.startTime)}</p>
                `;
                
                let payoutText = '';
                if (this.currentBet && this.currentBet.team.id === winner.id) {
                    const odds = parseFloat(this.currentBet.team.odds.split(':')[0]);
                    const payout = this.currentBet.amount * odds;
                    this.playerMoney += payout;
                    payoutText = `üéâ YOU WON! Payout: $${payout}`;
                    document.getElementById('money').textContent = this.playerMoney;
                } else if (this.currentBet) {
                    payoutText = `üòû You lost your bet on ${this.currentBet.team.name}`;
                } else {
                    payoutText = `No bet placed this race`;
                }
                
                payoutInfo.innerHTML = payoutText;
                document.getElementById('raceResults').style.display = 'block';
            }
            
            formatTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                const remainingMs = ms % 1000;
                return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}.${Math.floor(remainingMs / 100)}`;
            }
            
            drawTrack() {
                const ctx = this.ctx;
                
                // Draw grass background
                ctx.fillStyle = '#2a5a2a';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw track
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 4;
                
                // Outer track boundary
                ctx.beginPath();
                ctx.arc(this.track.centerX, this.track.centerY, this.track.radiusOuter, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Inner track boundary
                ctx.beginPath();
                ctx.arc(this.track.centerX, this.track.centerY, this.track.radiusInner, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw track surface
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.arc(this.track.centerX, this.track.centerY, this.track.radiusOuter, 0, 2 * Math.PI);
                ctx.arc(this.track.centerX, this.track.centerY, this.track.radiusInner, 0, 2 * Math.PI, true);
                ctx.fill();
                
                // Draw checkpoints
                this.track.checkpoints.forEach((checkpoint, i) => {
                    ctx.fillStyle = i === 0 ? '#FFD700' : '#FFF';
                    ctx.beginPath();
                    ctx.arc(checkpoint.x, checkpoint.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    if (i === 0) {
                        ctx.fillStyle = '#FFD700';
                        ctx.font = '12px Arial';
                        ctx.fillText('START/FINISH', checkpoint.x - 35, checkpoint.y - 15);
                    }
                });
            }
            
            drawCars() {
                this.cars.forEach(car => {
                    const ctx = this.ctx;
                    
                    ctx.save();
                    ctx.translate(car.x, car.y);
                    ctx.rotate(car.angle);
                    
                    // Car body
                    ctx.fillStyle = car.color;
                    ctx.fillRect(-6, -3, 12, 6);
                    
                    // Car outline
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-6, -3, 12, 6);
                    
                    // Position number
                    ctx.fillStyle = '#FFF';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(car.position.toString(), 0, 2);
                    
                    ctx.restore();
                    
                    // Speed trail effect
                    if (car.speed > 1) {
                        ctx.save();
                        ctx.globalAlpha = 0.3;
                        ctx.strokeStyle = car.color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(car.x, car.y);
                        ctx.lineTo(
                            car.x - car.vx * 5,
                            car.y - car.vy * 5
                        );
                        ctx.stroke();
                        ctx.restore();
                    }
                });
            }
            
            updateTimer() {
                if (this.gameState === 'racing') {
                    const elapsed = Date.now() - this.startTime;
                    document.getElementById('timer').textContent = this.formatTime(elapsed);
                }
            }
            
            gameLoop() {
                this.frameCount++;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw everything
                this.drawTrack();
                this.drawCars();
                
                // Update game state
                if (this.gameState === 'racing') {
                    this.cars.forEach(car => this.updateAICar(car));
                    this.updatePositions();
                    this.updateTimer();
                    this.checkRaceComplete();
                }
                
                // Continue game loop
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Global functions
        function resetRace() {
            document.getElementById('raceResults').style.display = 'none';
            game.gameState = 'betting';
            game.raceNumber++;
            game.currentBet = null;
            game.selectedTeam = null;
            document.getElementById('raceNumber').textContent = game.raceNumber;
            document.getElementById('raceStatus').textContent = 'Betting Open';
            document.getElementById('currentBet').innerHTML = '';
            document.getElementById('timer').textContent = '0:00';
            
            // Clear team selections
            document.querySelectorAll('.team-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            game.updateBetButton();
        }
        
        function closeStory() {
            document.getElementById('storyDetails').style.display = 'none';
        }
        
        // Start the game
        let game;
        window.addEventListener('load', () => {
            game = new RacingGame();
        });
    </script>
</body>
</html>