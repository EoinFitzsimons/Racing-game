<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Racing Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameContainer {
            position: relative;
            max-width: 100vw;
            max-height: 100vh;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: #2a5a2a;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 10;
        }

        #leaderboard {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 12px;
            min-width: 120px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 10;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid #fff;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.1s ease;
            backdrop-filter: blur(5px);
        }

        .control-btn:active {
            background: rgba(255,255,255,0.5);
            transform: scale(0.9);
            box-shadow: inset 0 0 20px rgba(255,255,255,0.3);
        }

        .control-btn.pressed {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 20;
        }

        #startBtn {
            padding: 15px 30px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }

        .steering-wheel {
            width: 100px;
            height: 100px;
            border: 4px solid #fff;
            border-radius: 50%;
            position: relative;
            background: rgba(255,255,255,0.1);
            transition: transform 0.1s ease;
            backdrop-filter: blur(5px);
        }

        .steering-indicator {
            width: 6px;
            height: 35px;
            background: #fff;
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 3px;
            transition: all 0.1s ease;
        }

        /* Gas and brake specific styling */
        #gasBtn {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }

        #gasBtn:active, #gasBtn.pressed {
            background: rgba(76, 175, 80, 0.6);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
        }

        #brakeBtn {
            background: rgba(244, 67, 54, 0.3);
            border-color: #f44336;
        }

        #brakeBtn:active, #brakeBtn.pressed {
            background: rgba(244, 67, 54, 0.6);
            box-shadow: 0 0 20px rgba(244, 67, 54, 0.7);
        }

        /* Responsive controls */
        @media (max-width: 480px) {
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }
            
            .steering-wheel {
                width: 80px;
                height: 80px;
            }
            
            .steering-indicator {
                width: 4px;
                height: 30px;
                top: 12px;
            }
        }

        /* Vibration feedback indicator */
        @keyframes vibrate {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .vibrating {
            animation: vibrate 0.1s ease-in-out;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div>Lap: <span id="lapCount">1/3</span></div>
            <div>Speed: <span id="speedometer">0</span> mph</div>
            <div>Time: <span id="timer">0:00</span></div>
        </div>

        <div id="leaderboard">
            <div style="font-weight: bold; margin-bottom: 5px;">Positions</div>
            <div id="positions"></div>
        </div>

        <div id="controls">
            <div class="control-btn" id="leftBtn">‚¨Ö</div>
            <div class="steering-wheel" id="steeringWheel">
                <div class="steering-indicator"></div>
            </div>
            <div class="control-btn" id="rightBtn">‚û°</div>
            <div class="control-btn" id="gasBtn">‚¨Ü</div>
            <div class="control-btn" id="brakeBtn">‚¨á</div>
        </div>

        <div id="startScreen">
            <h1>üèéÔ∏è Racing Game</h1>
            <p>Race against 7 AI opponents!</p>
            <p>Stay on track for best speed</p>
            <p>Use steering wheel or arrow buttons</p>
            <button id="startBtn">START RACE</button>
        </div>
    </div>

    <script>
        class RacingGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                this.gameState = 'menu';
                this.frameCount = 0;
                this.startTime = 0;
                
                this.cars = [];
                this.track = this.generateTrack();
                
                this.input = {
                    left: false,
                    right: false,
                    gas: false,
                    brake: false,
                    steerAngle: 0 // For analog steering
                };
                
                this.setupControls();
                this.setupCars();
                this.gameLoop();
            }
            
            setupCanvas() {
                const container = document.getElementById('gameContainer');
                const maxWidth = Math.min(window.innerWidth, 800);
                const maxHeight = Math.min(window.innerHeight, 600);
                
                this.canvas.width = maxWidth;
                this.canvas.height = maxHeight;
                
                container.style.width = maxWidth + 'px';
                container.style.height = maxHeight + 'px';
            }
            
            generateTrack() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radiusOuter = Math.min(centerX, centerY) - 50;
                const radiusInner = radiusOuter - 80;
                
                return {
                    centerX,
                    centerY,
                    radiusOuter,
                    radiusInner,
                    checkpoints: this.generateCheckpoints(centerX, centerY, (radiusOuter + radiusInner) / 2)
                };
            }
            
            generateCheckpoints(centerX, centerY, radius) {
                const checkpoints = [];
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    checkpoints.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius,
                        angle: angle
                    });
                }
                return checkpoints;
            }
            
            setupCars() {
                const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff', '#ffa544', '#a544ff'];
                const startRadius = (this.track.radiusOuter + this.track.radiusInner) / 2;
                
                for (let i = 0; i < 8; i++) {
                    const startAngle = -Math.PI / 2 + (i * 0.1);
                    const car = {
                        id: i,
                        x: this.track.centerX + Math.cos(startAngle) * startRadius,
                        y: this.track.centerY + Math.sin(startAngle) * startRadius,
                        vx: 0,
                        vy: 0,
                        angle: startAngle + Math.PI / 2,
                        speed: 0,
                        maxSpeed: i === 0 ? 5 : 4 + Math.random(),
                        acceleration: 0.3,
                        friction: 0.95,
                        turnSpeed: 0.05,
                        color: colors[i],
                        isPlayer: i === 0,
                        lap: 1,
                        checkpointIndex: 0,
                        position: i + 1,
                        onTrack: true,
                        aiTarget: 0
                    };
                    this.cars.push(car);
                }
            }
            
            setupControls() {
                const leftBtn = document.getElementById('leftBtn');
                const rightBtn = document.getElementById('rightBtn');
                const gasBtn = document.getElementById('gasBtn');
                const brakeBtn = document.getElementById('brakeBtn');
                const steeringWheel = document.getElementById('steeringWheel');
                const steeringIndicator = document.querySelector('.steering-indicator');
                const startBtn = document.getElementById('startBtn');
                
                // Enhanced touch controls with visual feedback
                const addTouchControls = (element, key) => {
                    element.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.input[key] = true;
                        element.classList.add('pressed');
                        this.hapticFeedback();
                    });
                    
                    element.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.input[key] = false;
                        element.classList.remove('pressed');
                    });
                    
                    element.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        this.input[key] = false;
                        element.classList.remove('pressed');
                    });
                    
                    // Mouse controls for desktop
                    element.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.input[key] = true;
                        element.classList.add('pressed');
                    });
                    
                    element.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        this.input[key] = false;
                        element.classList.remove('pressed');
                    });
                    
                    element.addEventListener('mouseleave', (e) => {
                        this.input[key] = false;
                        element.classList.remove('pressed');
                    });
                };
                
                // Add enhanced controls
                addTouchControls(leftBtn, 'left');
                addTouchControls(rightBtn, 'right');
                addTouchControls(gasBtn, 'gas');
                addTouchControls(brakeBtn, 'brake');
                
                // Steering wheel analog control
                let isDragging = false;
                let startAngle = 0;
                
                const getAngleFromEvent = (e) => {
                    const rect = steeringWheel.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    let clientX, clientY;
                    if (e.touches && e.touches[0]) {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    
                    return Math.atan2(clientY - centerY, clientX - centerX);
                };
                
                const startSteering = (e) => {
                    e.preventDefault();
                    isDragging = true;
                    startAngle = getAngleFromEvent(e);
                    this.hapticFeedback();
                };
                
                const updateSteering = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    
                    const currentAngle = getAngleFromEvent(e);
                    let angleDiff = currentAngle - startAngle;
                    
                    // Normalize angle difference
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Convert to steering input (-1 to 1)
                    this.input.steerAngle = Math.max(-1, Math.min(1, angleDiff / (Math.PI / 3)));
                    
                    // Update visual indicator
                    const rotation = this.input.steerAngle * 45; // Max 45 degrees rotation
                    steeringIndicator.style.transform = `translateX(-50%) rotate(${rotation}deg)`;
                    steeringWheel.style.transform = `rotate(${rotation}deg)`;
                };
                
                const endSteering = (e) => {
                    e.preventDefault();
                    isDragging = false;
                    this.input.steerAngle = 0;
                    
                    // Reset visual state
                    steeringIndicator.style.transform = 'translateX(-50%) rotate(0deg)';
                    steeringWheel.style.transform = 'rotate(0deg)';
                };
                
                // Touch events for steering wheel
                steeringWheel.addEventListener('touchstart', startSteering);
                document.addEventListener('touchmove', updateSteering);
                document.addEventListener('touchend', endSteering);
                
                // Mouse events for steering wheel
                steeringWheel.addEventListener('mousedown', startSteering);
                document.addEventListener('mousemove', updateSteering);
                document.addEventListener('mouseup', endSteering);
                
                // Enhanced keyboard controls
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            this.input.left = true;
                            leftBtn.classList.add('pressed');
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            this.input.right = true;
                            rightBtn.classList.add('pressed');
                            break;
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            this.input.gas = true;
                            gasBtn.classList.add('pressed');
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            this.input.brake = true;
                            brakeBtn.classList.add('pressed');
                            break;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            this.input.left = false;
                            leftBtn.classList.remove('pressed');
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            this.input.right = false;
                            rightBtn.classList.remove('pressed');
                            break;
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            this.input.gas = false;
                            gasBtn.classList.remove('pressed');
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            this.input.brake = false;
                            brakeBtn.classList.remove('pressed');
                            break;
                    }
                });
                
                startBtn.addEventListener('click', () => {
                    this.startRace();
                });
            }
            
            // Haptic feedback for mobile devices
            hapticFeedback() {
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            }
            
            startRace() {
                this.gameState = 'racing';
                this.startTime = Date.now();
                document.getElementById('startScreen').style.display = 'none';
            }
            
            updateCar(car) {
                if (car.isPlayer) {
                    this.updatePlayerCar(car);
                } else {
                    this.updateAICar(car);
                }
                
                // Physics
                car.x += car.vx;
                car.y += car.vy;
                
                // Check if on track
                const distFromCenter = Math.sqrt(
                    Math.pow(car.x - this.track.centerX, 2) + 
                    Math.pow(car.y - this.track.centerY, 2)
                );
                
                car.onTrack = distFromCenter <= this.track.radiusOuter && distFromCenter >= this.track.radiusInner;
                
                // Off-track penalty with visual feedback
                if (!car.onTrack && car.isPlayer) {
                    car.vx *= 0.8;
                    car.vy *= 0.8;
                    car.maxSpeed = 3;
                    
                    // Add screen shake effect
                    if (this.frameCount % 10 === 0) {
                        document.getElementById('gameContainer').classList.add('vibrating');
                        setTimeout(() => {
                            document.getElementById('gameContainer').classList.remove('vibrating');
                        }, 100);
                    }
                } else if (!car.onTrack) {
                    car.vx *= 0.8;
                    car.vy *= 0.8;
                    car.maxSpeed = 2;
                } else {
                    car.maxSpeed = car.isPlayer ? 5 : 4 + Math.random();
                }
                
                // Update checkpoint progress
                this.updateCheckpoints(car);
                
                // Update UI for player
                if (car.isPlayer) {
                    document.getElementById('speedometer').textContent = Math.round(car.speed * 20);
                    document.getElementById('lapCount').textContent = `${car.lap}/3`;
                }
            }
            
            updatePlayerCar(car) {
                // Enhanced steering with analog support
                let steerInput = 0;
                
                if (this.input.steerAngle !== 0) {
                    // Use analog steering from wheel
                    steerInput = this.input.steerAngle;
                } else {
                    // Use digital steering from buttons
                    if (this.input.left) steerInput -= 1;
                    if (this.input.right) steerInput += 1;
                }
                
                // Apply steering with speed-dependent sensitivity
                const steerSensitivity = Math.max(0.5, 1 - car.speed / car.maxSpeed * 0.3);
                car.angle += steerInput * car.turnSpeed * steerSensitivity;
                
                // Enhanced acceleration with progressive response
                if (this.input.gas) {
                    const accelRate = car.onTrack ? car.acceleration : car.acceleration * 0.7;
                    car.speed = Math.min(car.speed + accelRate, car.maxSpeed);
                } else if (this.input.brake) {
                    car.speed = Math.max(car.speed - car.acceleration * 2, -car.maxSpeed / 2);
                } else {
                    // Improved natural deceleration
                    car.speed *= car.onTrack ? car.friction : car.friction * 0.9;
                }
                
                // Update velocity
                car.vx = Math.cos(car.angle) * car.speed;
                car.vy = Math.sin(car.angle) * car.speed;
            }
            
            updateAICar(car) {
                // Simple AI: follow the track
                const targetCheckpoint = this.track.checkpoints[car.aiTarget];
                const dx = targetCheckpoint.x - car.x;
                const dy = targetCheckpoint.y - car.y;
                const targetAngle = Math.atan2(dy, dx);
                
                // Check if reached target checkpoint
                if (Math.sqrt(dx * dx + dy * dy) < 40) {
                    car.aiTarget = (car.aiTarget + 1) % this.track.checkpoints.length;
                }
                
                // Steer towards target
                let angleDiff = targetAngle - car.angle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                if (Math.abs(angleDiff) > 0.1) {
                    car.angle += Math.sign(angleDiff) * car.turnSpeed;
                }
                
                // AI always accelerates (simple AI)
                car.speed = Math.min(car.speed + car.acceleration, car.maxSpeed);
                
                // Update velocity
                car.vx = Math.cos(car.angle) * car.speed;
                car.vy = Math.sin(car.angle) * car.speed;
            }
            
            updateCheckpoints(car) {
                const checkpoint = this.track.checkpoints[car.checkpointIndex];
                const dx = car.x - checkpoint.x;
                const dy = car.y - checkpoint.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 30) {
                    car.checkpointIndex++;
                    if (car.checkpointIndex >= this.track.checkpoints.length) {
                        car.checkpointIndex = 0;
                        car.lap++;
                    }
                }
            }
            
            updatePositions() {
                // Sort cars by lap and checkpoint progress
                this.cars.sort((a, b) => {
                    if (a.lap !== b.lap) return b.lap - a.lap;
                    return b.checkpointIndex - a.checkpointIndex;
                });
                
                // Update positions
                this.cars.forEach((car, index) => {
                    car.position = index + 1;
                });
                
                // Update leaderboard display
                const positionsDiv = document.getElementById('positions');
                positionsDiv.innerHTML = this.cars.map(car => 
                    `<div style="color: ${car.color}">${car.position}. ${car.isPlayer ? 'YOU' : 'AI ' + car.id}</div>`
                ).join('');
            }
            
            drawTrack() {
                this.ctx.fillStyle = '#2a5a2a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw track (gray ring)
                this.ctx.fillStyle = '#666';
                this.ctx.beginPath();
                this.ctx.arc(this.track.centerX, this.track.centerY, this.track.radiusOuter, 0, Math.PI * 2);
                this.ctx.arc(this.track.centerX, this.track.centerY, this.track.radiusInner, 0, Math.PI * 2, true);
                this.ctx.fill();
                
                // Draw start/finish line
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(this.track.centerX, this.track.centerY - this.track.radiusOuter);
                this.ctx.lineTo(this.track.centerX, this.track.centerY - this.track.radiusInner);
                this.ctx.stroke();
            }
            
            drawCar(car) {
                this.ctx.save();
                this.ctx.translate(car.x, car.y);
                this.ctx.rotate(car.angle);
                
                // Car body
                this.ctx.fillStyle = car.color;
                this.ctx.fillRect(-8, -4, 16, 8);
                
                // Car outline
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(-8, -4, 16, 8);
                
                // Direction indicator
                this.ctx.fillStyle = '#fff';
                this.ctx.fillRect(6, -2, 4, 4);
                
                this.ctx.restore();
                
                // Position number above car
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(car.position, car.x, car.y - 15);
            }
            
            updateTimer() {
                if (this.gameState === 'racing') {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }
            
            update() {
                if (this.gameState === 'racing') {
                    this.cars.forEach(car => this.updateCar(car));
                    this.updatePositions();
                    this.updateTimer();
                    
                    // Check for race finish
                    if (this.cars[0].lap > 3) {
                        this.gameState = 'finished';
                    }
                }
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawTrack();
                this.cars.forEach(car => this.drawCar(car));
                
                if (this.gameState === 'finished') {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Race Finished!', this.canvas.width / 2, this.canvas.height / 2);
                    
                    const playerCar = this.cars.find(car => car.isPlayer);
                    this.ctx.fillText(`You finished ${playerCar.position}${this.getOrdinalSuffix(playerCar.position)}!`, 
                        this.canvas.width / 2, this.canvas.height / 2 + 40);
                }
            }
            
            getOrdinalSuffix(num) {
                const suffix = ['th', 'st', 'nd', 'rd'];
                const value = num % 100;
                return suffix[(value - 20) % 10] || suffix[value] || suffix[0];
            }
            
            gameLoop() {
                this.update();
                this.draw();
                this.frameCount++;
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            new RacingGame();
        });
        
        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                location.reload();
            }, 100);
        });
    </script>
</body>
</html>